<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<title>Endless 3D Car Runner</title>

<!-- Import map for Three.js (v0.164.1) and loaders -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
    "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.164.1/examples/jsm/loaders/GLTFLoader.js",
    "three/examples/jsm/loaders/DRACOLoader.js": "https://unpkg.com/three@0.164.1/examples/jsm/loaders/DRACOLoader.js"
  }
}
</script>

<style>
  html,body{height:100%;margin:0;background:#a0d7e6;overflow:hidden;font-family:sans-serif; -webkit-tap-highlight-color: transparent;}
  body{overscroll-behavior:none; touch-action:none; -webkit-user-select:none; user-select:none}
  #container{width:100%;height:100%;display:block}
  canvas{display:block}

  /* Loading overlay */
  #loading {
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,0.6); color:white; font-size:1.25em; z-index:200;
    transition:opacity .5s ease; pointer-events:auto;
  }
  #loading.hidden{opacity:0; pointer-events:none; display:flex}

  /* UI */
  #ui {
    position:fixed; left:10px; top:10px; z-index:50; color:white; text-shadow:0 2px 4px rgba(0,0,0,0.8);
    background: rgba(0,0,0,0.15); padding:8px 10px; border-radius:6px;
  }
  #score{font-weight:600}

  /* Game Over */
  #gameOver {
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    color:#ff4444; font-size:4em; font-weight:700; text-shadow:0 6px 18px rgba(0,0,0,0.5);
    z-index:101; display:none; pointer-events:none;
  }

  /* Touch Controls */
  .ctrl {
    position:fixed; bottom:20px; width:64px; height:64px; border-radius:50%;
    background:rgba(255,255,255,0.3); display:flex; align-items:center; justify-content:center;
    font-size:2.5em; border:1px solid rgba(0,0,0,0.4); z-index:60; -webkit-user-select:none; user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  .ctrl:active { background: rgba(255,255,255,0.5) }
  #leftBtn{left:20px}
  #rightBtn{right:20px}

  /* Prevent highlight on iOS */
  button { -webkit-tap-highlight-color: rgba(0,0,0,0); }
</style>
</head>
<body>
  <div id="container"></div>

  <div id="loading">Loading... <span id="loadingPct"></span></div>

  <div id="ui">
    <div id="score">Score: 0</div>
  </div>

  <div id="gameOver">GAME OVER!</div>

  <div id="leftBtn" class="ctrl">◀</div>
  <div id="rightBtn" class="ctrl">▶</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

/////// Config & Globals ///////
const container = document.getElementById('container');
const loadingEl = document.getElementById('loading');
const loadingPct = document.getElementById('loadingPct');
const scoreEl = document.getElementById('score');
const gameOverEl = document.getElementById('gameOver');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

const roadWidth = 10;
const roadLength = 200;
const kerbWidth = 0.3;
const buildingSpacing = 15;
const lightSpacing = 20;
const driveSpeed = 0.5; // scenery movement baseline
const carMoveSpeed = 0.15; // lateral car speed
const enemyCarSpeed = 0.4;
const pointCount = 15;

let score = 0;
let isGameOver = false;

let scene, camera, renderer, clock;
let playerGroup, playerBaseY = 0.5, playerHalfWidth = 1.0;
let enemyGroup;
let points = [];
let segments = [];
let buildings = [];
let lights = [];
let kerbs = [];
let roadLines = [];
let trafficLights = [];
let moveLeft = false, moveRight = false;
let loadingManager;

/////// Setup Scene ///////
function setup() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xa0d7e6);
  scene.fog = new THREE.Fog(0xa0d7e6, roadLength * 0.4, roadLength * 0.9);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, playerBaseY + 3, -7);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  container.appendChild(renderer.domElement);

  // lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 1.5);
  dir.position.set(-10, 30, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048, 2048);
  dir.shadow.camera.left = -100; dir.shadow.camera.right = 100;
  dir.shadow.camera.top = 100; dir.shadow.camera.bottom = -100;
  scene.add(dir);

  // ground (green) beneath road
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x55aa55, roughness: 1.0 });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(roadLength * 1.5, roadLength), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.05;
  ground.receiveShadow = true;
  scene.add(ground);

  // road plane (gray)
  const roadMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.95 });
  const road = new THREE.Mesh(new THREE.PlaneGeometry(roadWidth, roadLength), roadMat);
  road.rotation.x = -Math.PI/2;
  road.receiveShadow = true;
  road.name = 'road';
  scene.add(road);

  // kerbs with striped texture
  createKerbs();

  // create recycle segments, road lines, buildings, lights
  createSegmentsAndDecor();

  // create player & enemy placeholders; load model then replace
  playerGroup = new THREE.Group();
  playerGroup.position.set(0, playerBaseY, 0);
  scene.add(playerGroup);

  enemyGroup = new THREE.Group();
  enemyGroup.position.set(0, playerBaseY, roadLength * 0.7);
  scene.add(enemyGroup);

  // points
  for (let i=0;i<pointCount;i++){
    const p = createPoint();
    points.push(p);
    scene.add(p.mesh);
  }

  // traffic lights pair at roadLength * 0.4
  createTrafficLights(roadLength * 0.4);

  // camera look
  camera.lookAt(0, playerBaseY + 1, 20);

  // clock
  clock = new THREE.Clock();

  // input handlers
  setupInput();

  // handle resize
  window.addEventListener('resize', onResize);
}

/////// Loading / Model ///////
function setupLoadersAndStart() {
  loadingManager = new THREE.LoadingManager();
  loadingManager.onStart = function () {
    loadingPct.textContent = '';
  };
  loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
    const pct = Math.round((itemsLoaded / itemsTotal) * 100);
    loadingEl.textContent = `Loading... ${pct}%`;
  };
  loadingManager.onLoad = function () {
    setTimeout(()=>{ loadingEl.classList.add('hidden'); }, 500);
  };
  loadingManager.onError = function (url) {
    loadingEl.textContent = `Error loading ${url}`;
  };

  // DRACO & GLTF
  const draco = new DRACOLoader(loadingManager);
  draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
  const gltfLoader = new GLTFLoader(loadingManager);
  gltfLoader.setDRACOLoader(draco);

  // load ferrari
  const modelUrl = 'https://threejs.org/examples/models/gltf/ferrari.glb';
  gltfLoader.load(modelUrl,
    (gltf) => {
      // integrate model
      const model = gltf.scene;
      model.scale.setScalar(0.8);
      model.rotation.y = Math.PI; // face forward (-Z)
      // compute bbox to place at proper baseY
      const box = new THREE.Box3().setFromObject(model);
      const size = new THREE.Vector3(); box.getSize(size);
      const min = new THREE.Vector3(); box.getMin(min);
      const baseY = -min.y;
      // place model so its base sits at playerBaseY
      model.position.y = playerBaseY - baseY;
      model.traverse(m => { if (m.isMesh) { m.castShadow = true; m.receiveShadow = true; } });
      // add to playerGroup
      playerGroup.add(model);
      // create enemy by cloning (deep)
      const enemy = model.clone(true);
      enemy.traverse(m => {
        if (m.isMesh && m.material) {
          // colorize to blue
          if (m.material.color) m.material.color.setHex(0x0000ff);
        }
      });
      enemy.scale.setScalar(0.8);
      enemy.position.set((Math.random()>0.5?1:-1) * roadWidth/4, playerBaseY - baseY, roadLength * 0.7);
      enemyGroup.add(enemy);

    },
    (xhr) => {
      // progress handled by manager, but we can also use this
      // no-op
    },
    (err) => {
      console.warn('Model failed to load, using fallback car.', err);
      loadingEl.textContent = 'Model failed to load — using fallback';
      createFallbackPlayer();
    }
  );
}

function createFallbackPlayer(){
  // red box car fallback
  const body = new THREE.Mesh(new THREE.BoxGeometry(2,1,4), new THREE.MeshStandardMaterial({color:0xff0000}));
  body.position.y = playerBaseY;
  body.castShadow = true; body.receiveShadow = true;
  playerGroup.add(body);

  // enemy blue clone
  const e = new THREE.Mesh(new THREE.BoxGeometry(2,1,4), new THREE.MeshStandardMaterial({color:0x0000ff}));
  e.position.set((Math.random()>0.5?1:-1) * roadWidth/4, playerBaseY, roadLength * 0.7);
  e.castShadow = true; e.receiveShadow = true;
  enemyGroup.add(e);
}

/////// Helpers: Kerbs, Segments, Buildings, Lights ///////
function createKerbs(){
  // canvas texture for stripes
  const canvas = document.createElement('canvas');
  canvas.width = 64; canvas.height = 8;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ff0000'; ctx.fillRect(0,0,32,8);
  ctx.fillStyle = '#ffffff'; ctx.fillRect(32,0,32,8);
  const tex = new THREE.CanvasTexture(canvas);
  tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(roadLength / 8, 1);

  const kerbMat = new THREE.MeshStandardMaterial({ map: tex });
  const left = new THREE.Mesh(new THREE.BoxGeometry(kerbWidth, 0.2, roadLength), kerbMat);
  left.position.set(-roadWidth/2 - kerbWidth/2, 0.1, 0);
  left.castShadow = true; left.receiveShadow = true;
  scene.add(left); kerbs.push(left);

  const right = left.clone();
  right.position.x = roadWidth/2 + kerbWidth/2;
  scene.add(right); kerbs.push(right);
}

function createSegmentsAndDecor(){
  const segCount = Math.ceil(roadLength / 20) + 6; // more segments for recycling buffer
  for (let i=0;i<segCount;i++){
    const seg = new THREE.Group();
    seg.userData.segmentIndex = i;

    // no additional road mesh needed; road lines and decor are added relative in world space
    // add dashed center lines for segment
    const dashGeo = new THREE.BoxGeometry(0.3, 0.02, 4);
    const dashMat = new THREE.MeshStandardMaterial({color:0xffffff});
    for (let z = -i*20 - 10; z > -i*20 - 20; z -= 6) {
      const dash = new THREE.Mesh(dashGeo, dashMat);
      dash.position.set(0, 0.02, z);
      dash.castShadow = false; dash.receiveShadow = true;
      seg.add(dash);
      roadLines.push(dash);
    }

    // buildings (randomized)
    const buildingsPerSegment = Math.max(1, Math.floor(20 / buildingSpacing));
    for (let b=0;b<buildingsPerSegment;b++){
      const w = THREE.MathUtils.randFloat(4,12);
      const d = THREE.MathUtils.randFloat(4,12);
      const h = THREE.MathUtils.randFloat(10,40);
      const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL( Math.random()*0.2 + 0.5, 0.15, 0.12 + Math.random()*0.25 ) });
      const box = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
      box.position.set((Math.random()>0.5?-1:1) * (roadWidth/2 + 6 + Math.random()*8), h/2 - 0.05, -i*20 - Math.random()*20);
      box.castShadow = true; box.receiveShadow = true;
      seg.add(box);
      buildings.push(box);
    }

    // street lights every lightSpacing within the segment
    for (let z = -i*20 - 18; z < -i*20; z += lightSpacing) {
      for (let side of [-1,1]) {
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,6,8), new THREE.MeshStandardMaterial({color:0x222222}));
        pole.position.set(side*(roadWidth/2 - 0.6), 3, z);
        pole.castShadow = true;
        const lamp = new THREE.Mesh(new THREE.SphereGeometry(0.22,10,8), new THREE.MeshStandardMaterial({emissive:0xfff2a8, emissiveIntensity:0.9}));
        lamp.position.set(0, -2.6, 0);
        pole.add(lamp);
        seg.add(pole);
        lights.push(pole);
      }
    }

    // position segment root so children are in world aligned z
    seg.position.z = -i*20;
    segments.push(seg);
    scene.add(seg);
  }
}

function createTrafficLights(zPos){
  const pair = new THREE.Group();
  // left
  const poleL = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,5,8), new THREE.MeshStandardMaterial({color:0x222222}));
  poleL.position.set(-roadWidth/2 - 1, 2.6, zPos);
  const housingL = new THREE.Mesh(new THREE.BoxGeometry(0.5,1.2,0.3), new THREE.MeshStandardMaterial({color:0x111111}));
  housingL.position.set(-roadWidth/2 - 1, 3.1, zPos);
  const r = new THREE.Mesh(new THREE.SphereGeometry(0.12,8,6), new THREE.MeshStandardMaterial({emissive:0x000000}));
  r.position.set(-roadWidth/2 - 1, 3.45, zPos+0.18);
  const y = r.clone(); y.position.set(-roadWidth/2 - 1, 3.05, zPos+0.18);
  const g = r.clone(); g.position.set(-roadWidth/2 - 1, 2.65, zPos+0.18);
  pair.add(poleL, housingL, r, y, g);

  // right mirror
  const poleR = poleL.clone(); poleR.position.x = roadWidth/2 + 1;
  const housingR = housingL.clone(); housingR.position.x = roadWidth/2 + 1;
  const r2 = r.clone(); r2.position.x = roadWidth/2 + 1;
  const y2 = y.clone(); y2.position.x = roadWidth/2 + 1;
  const g2 = g.clone(); g2.position.x = roadWidth/2 + 1;
  pair.add(poleR, housingR, r2, y2, g2);

  // simple cycle
  let idx = 0;
  const states = ['green','yellow','red'];
  function cycle(){
    const s = states[idx%3];
    [r,y,g,r2,y2,g2].forEach(m=> m.material.emissive.setHex(0x000000));
    if(s==='green'){ g.material.emissive.setHex(0x22ff22); g2.material.emissive.setHex(0x22ff22); }
    if(s==='yellow'){ y.material.emissive.setHex(0xffaa00); y2.material.emissive.setHex(0xffaa00); }
    if(s==='red'){ r.material.emissive.setHex(0xff0000); r2.material.emissive.setHex(0xff0000); }
    idx++;
    setTimeout(cycle, s==='green'?4500:(s==='yellow'?1200:4200));
  }
  cycle();

  pair.position.z = zPos;
  trafficLights.push(pair);
  scene.add(pair);
}

function createPoint(){
  const geo = new THREE.SphereGeometry(0.3, 12, 10);
  const mat = new THREE.MeshStandardMaterial({ color:0xffe066, emissive:0xffe066, emissiveIntensity:0.6 });
  const m = new THREE.Mesh(geo, mat);
  // random lane inside road bounds
  const x = THREE.MathUtils.randFloat(-roadWidth/2 + 1, roadWidth/2 - 1);
  const z = THREE.MathUtils.randFloat(-roadLength/2, roadLength/2);
  m.position.set(x, 0.3, z);
  m.castShadow = false; m.receiveShadow = true;
  return { mesh: m, collected:false };
}

/////// Input: Keyboard & Touch ///////
function setupInput(){
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'ArrowLeft' || e.code === 'KeyA'){ moveLeft = true; }
    if(e.code === 'ArrowRight' || e.code === 'KeyD'){ moveRight = true; }
    if(e.code === 'KeyR'){ restartGame(); }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code === 'ArrowLeft' || e.code === 'KeyA'){ moveLeft = false; }
    if(e.code === 'ArrowRight' || e.code === 'KeyD'){ moveRight = false; }
  });

  // Touch buttons: pointer events recommended (works with mouse & touch)
  leftBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); moveLeft = true; });
  leftBtn.addEventListener('pointerup', (e)=>{ e.preventDefault(); moveLeft = false; });
  leftBtn.addEventListener('pointercancel', ()=>{ moveLeft = false; });
  leftBtn.addEventListener('pointerout', ()=>{ moveLeft = false; });

  rightBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); moveRight = true; });
  rightBtn.addEventListener('pointerup', (e)=>{ e.preventDefault(); moveRight = false; });
  rightBtn.addEventListener('pointercancel', ()=>{ moveRight = false; });
  rightBtn.addEventListener('pointerout', ()=>{ moveRight = false; });

  // prevent default gestures
  ['touchstart','touchmove','touchend','touchcancel'].forEach(ev => {
    window.addEventListener(ev, (e)=>{ e.preventDefault(); }, {passive:false});
  });
}

/////// Game Loop & Updates ///////
function updateScenery(delta){
  // move segments and children backward (simulate forward motion)
  const moveDist = driveSpeed * delta * 60; // scale visually
  segments.forEach(seg=>{
    seg.position.z += -moveDist;
    // if segment too far behind, recycle it ahead
    if(seg.position.z < -roadLength - 40){
      seg.position.z += segments.length * 20;
    }
  });

  // move kerbs
  kerbs.forEach(k=>{
    k.position.z += -moveDist;
    if(k.position.z < -roadLength - 40) k.position.z += segments.length * 20;
  });

  // move buildings & lights similarly
  buildings.forEach(b=>{
    b.position.z += -moveDist;
    if(b.position.z < -roadLength - 40) b.position.z += segments.length * 20;
  });
  lights.forEach(l=>{
    l.position.z += -moveDist;
    if(l.position.z < -roadLength - 40) l.position.z += segments.length * 20;
  });

  // road lines
  roadLines.forEach(r=>{
    r.position.z += -moveDist;
    if(r.position.z < -roadLength - 40) r.position.z += segments.length * 20;
  });

  // traffic lights (move and recycle)
  trafficLights.forEach(t=>{
    t.position.z += -moveDist;
    if(t.position.z < -roadLength - 40) t.position.z += segments.length * 20;
  });

  // points move (scenery) and recycle
  points.forEach(p=>{
    if(p.collected) return;
    p.mesh.position.z += -moveDist;
    if(p.mesh.position.z < -roadLength/2 - 10){
      // recycle ahead
      p.mesh.position.z += roadLength;
      p.mesh.position.x = THREE.MathUtils.randFloat(-roadWidth/2 + 1, roadWidth/2 - 1);
    }
  });

  // enemy moves independently towards player direction (z decreases)
  if(enemyGroup.children.length > 0){
    enemyGroup.children.forEach(e=>{
      e.position.z += -enemyCarSpeed * delta * 60;
      // if off-screen behind, recycle ahead randomly in lanes
      if(e.position.z < -roadLength/2 - 20){
        e.position.z += roadLength + THREE.MathUtils.randFloat(0, roadLength/2);
        e.position.x = (Math.random()>0.5?1:-1) * (roadWidth/4);
      }
    });
  }
}

function updatePlayer(delta){
  // lateral movement based on moveLeft/moveRight
  let targetX = playerGroup.position.x;
  if(moveLeft) targetX -= carMoveSpeed * delta * 60;
  if(moveRight) targetX += carMoveSpeed * delta * 60;
  // clamp to bounds
  const bound = (roadWidth/2 - kerbWidth - playerHalfWidth);
  targetX = THREE.MathUtils.clamp(targetX, -bound, bound);
  // smooth lerp
  playerGroup.position.x = THREE.MathUtils.lerp(playerGroup.position.x, targetX, 0.18);
}

function updateCamera(delta){
  // camera should follow player's x position smoothly and look ahead
  const targetPos = new THREE.Vector3(playerGroup.position.x, playerBaseY + 3, playerGroup.position.z - 7);
  camera.position.lerp(targetPos, 0.1);
  camera.lookAt(new THREE.Vector3(playerGroup.position.x, playerBaseY + 1, playerGroup.position.z + 5));
}

function checkCollisions(){
  if(isGameOver) return;
  // player box
  const playerBox = new THREE.Box3().setFromObject(playerGroup);
  // enemy boxes
  enemyGroup.children.forEach(e=>{
    const eb = new THREE.Box3().setFromObject(e);
    if(playerBox.intersectsBox(eb)){
      // collision -> game over
      isGameOver = true;
      gameOverEl.style.display = 'block';
    }
  });

  // points
  points.forEach(p=>{
    if(p.collected) return;
    const pb = new THREE.Box3().setFromObject(p.mesh);
    if(playerBox.intersectsBox(pb)){
      p.collected = true;
      p.mesh.visible = false;
      score += 10;
      scoreEl.textContent = `Score: ${score}`;
      // respawn after some time to keep gameplay
      setTimeout(()=>{
        p.mesh.position.z = THREE.MathUtils.randFloat(playerGroup.position.z + 50, playerGroup.position.z + 200);
        p.mesh.position.x = THREE.MathUtils.randFloat(-roadWidth/2 + 1, roadWidth/2 - 1);
        p.collected = false; p.mesh.visible = true;
      }, 3000);
    }
  });
}

function gameLoop(){
  if(isGameOver) return;
  const delta = Math.min(0.05, clock.getDelta());
  updateScenery(delta);
  updatePlayer(delta);
  updateCamera(delta);
  checkCollisions();
  renderer.render(scene, camera);
  requestAnimationFrame(gameLoop);
}

/////// Restart ///////
function restartGame(){
  score = 0; scoreEl.textContent = `Score: ${score}`;
  isGameOver = false;
  gameOverEl.style.display = 'none';
  playerGroup.position.set(0, playerBaseY, 0);
  enemyGroup.position.set(0, playerBaseY, roadLength * 0.7);
  // reset points
  points.forEach((p, i)=>{
    p.collected = false; p.mesh.visible = true;
    p.mesh.position.z = THREE.MathUtils.randFloat(-roadLength/2, roadLength/2);
  });
  clock.start();
  gameLoop();
}

function onResize(){
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

/////// Initialize everything ///////
setup();
setupLoadersAndStart();
loadingEl.textContent = 'Loading...';
createFallbackPlayer(); // create fallback early so user always sees a car - this will be replaced when GLTF loads (if it does)

// start loop after small delay to allow loading manager to begin
setTimeout(()=>{
  clock.start();
  gameLoop();
}, 200);

</script>
</body>
</html>
